Total: 37 samples
      28  75.7%  75.7%       37 100.0% worker
       8  21.6%  97.3%        8  21.6% __strcmp_sse42
       1   2.7% 100.0%        9  24.3% SortedList_insert
       0   0.0% 100.0%       37 100.0% __clone
       0   0.0% 100.0%       37 100.0% start_thread
ROUTINE ====================== worker in /u/eng/ugrad/beb/lab2b/lab2_list.c
    28     37 Total samples (flat / cumulative)
     .      .   82: 		free(rand_key);
     .      .   83: 	}
     .      .   84: }
     .      .   85: 
     .      .   86: // Thread routine
---
     .      .   87: void* worker(void* tID){
     .      .   88: 
     .      .   89: 	// Lock timers
     .      .   90: 	struct timespec lock_start, lock_end;
     .      .   91: 
     .      .   92: 	// Insert elements into list
     .      .   93: 
     .      .   94: 	/* Fine Grained Locking */
     .      .   95: 	// int i;
     .      .   96: 	// for(i = *(int*)tID; i < numelems; i+= numthreads){
     .      .   97: 	// 	switch(m_sync){
     .      .   98: 	//		
     .      .   99: 	// 		// Mutex
     .      .  100: 	// 		case 'm':
     .      .  101: 	// 			pthread_mutex_lock(&mutex);
     .      .  102: 	// 			SortedList_insert(list, &elements[i]);
     .      .  103: 	// 			pthread_mutex_unlock(&mutex);
     .      .  104: 	// 			break;
     .      .  105: 	//		
     .      .  106: 	// 		// Spin-lock
     .      .  107: 	// 		case 's':
     .      .  108: 	// 			while(__sync_lock_test_and_set(&spin_lock, 1))
     .      .  109: 	// 				;
     .      .  110: 	// 			SortedList_insert(list, &elements[i]);
     .      .  111: 	// 			__sync_lock_release(&spin_lock);
     .      .  112: 	// 			break;
     .      .  113: 	//
     .      .  114: 	// 		// Without locks
     .      .  115: 	// 		default:
     .      .  116: 	// 			SortedList_insert(list, &elements[i]);
     .      .  117: 	// 			break;
     .      .  118: 	// 	}
     .      .  119: 	// }
     .      .  120: 
     .      .  121: 	/* Course Grained Locking */
     .      .  122: 	switch(m_sync){
     .      .  123: 	
     .      .  124: 	// Mutex
     .      .  125: 	case 'm':
     .      .  126: 		
     .      .  127: 		// Time the wait for thread to acquire mutex
     .      .  128: 		if(clock_gettime(CLOCK_MONOTONIC, &lock_start) == -1){
     .      .  129: 			fprintf(stderr, "Error getting lock start time\n");
     .      .  130: 			exit(1);
     .      .  131: 		}
     .      .  132: 		pthread_mutex_lock(&mutex);
     .      .  133: 		if(clock_gettime(CLOCK_MONOTONIC, &lock_end) == -1){
     .      .  134: 			fprintf(stderr, "Error getting lock end time\n");
     .      .  135: 			exit(1);
     .      .  136: 		}
     .      .  137: 
     .      .  138: 		// Calculate wait time
     .      .  139: 		long long wait_time = 1000000000 * (lock_end.tv_sec - lock_start.tv_sec) + (lock_end.tv_nsec - lock_start.tv_nsec);
     .      .  140: 		locktimers[*(int*)tID] = wait_time;
     .      .  141: 
     .      .  142: 		break;
     .      .  143: 	
     .      .  144: 	// Spin-lock
     .      .  145: 	case 's':
    27     27  146: 		while(__sync_lock_test_and_set(&spin_lock, 1))
     .      .  147: 			;
     .      .  148: 		break;
     .      .  149: 
     .      .  150: 	// Without locks
     .      .  151: 	default:
     .      .  152: 		break;
     .      .  153: 	}
     .      .  154: 
     .      .  155: 	int i;
     1      1  156: 	for(i = *(int*)tID; i < numelems; i+= numthreads)
     .      9  157: 		SortedList_insert(list, &elements[i]);
     .      .  158: 
     .      .  159: 	// Get the list length
     .      .  160: 	listlen = SortedList_length(list);
     .      .  161: 	
     .      .  162: 	// Check if the length of list is zero
     .      .  163: 	if(listlen == -1){
     .      .  164: 		fprintf(stderr, "Error: List length is corrupted after insertion; it is: %d\n",listlen);
     .      .  165: 		exit(2);
     .      .  166: 	}
     .      .  167: 
     .      .  168: 	// Look up and delete each of the keys it had previously inserted
     .      .  169: 	
     .      .  170:    	/* Fine Grained Locking */
     .      .  171: 	// int j;
     .      .  172: 	// for(j = *(int*)tID; j < numelems; j+= numthreads){
     .      .  173: 	// 	switch(m_sync){
     .      .  174: 	//
     .      .  175: 	// 		// Mutex
     .      .  176: 	// 		case 'm':
     .      .  177: 	// 			pthread_mutex_lock(&mutex);
     .      .  178: 	// 			SortedList_delete(SortedList_lookup(list, elements[j].key));
     .      .  179: 	// 			pthread_mutex_unlock(&mutex);
     .      .  180: 	//
     .      .  181: 	// 		// Spin-lock
     .      .  182: 	// 		case 's':
     .      .  183: 	// 			while(__sync_lock_test_and_set(&spin_lock, 1))
     .      .  184: 	// 				;
     .      .  185: 	// 			SortedList_delete(SortedList_lookup(list, elements[j].key));
     .      .  186: 	// 			__sync_lock_release(&spin_lock);
     .      .  187: 	//
     .      .  188: 	// 		// Without locks
     .      .  189: 	// 		default:
     .      .  190: 	// 			SortedList_delete(SortedList_lookup(list, elements[j].key));
     .      .  191: 	// 			break;
     .      .  192: 	// 	}
     .      .  193: 	// }
     .      .  194: 
     .      .  195: 
     .      .  196: 	// Course Grained Locking
     .      .  197: 	int j;
     .      .  198: 	for(j = *(int*)tID; j < numelems; j+= numthreads)
     .      .  199: 		SortedList_delete(SortedList_lookup(list, elements[j].key));
     .      .  200: 
     .      .  201: 	switch(m_sync){
     .      .  202: 	
     .      .  203: 		// Mutex
     .      .  204: 		case 'm':
     .      .  205: 			pthread_mutex_unlock(&mutex);
     .      .  206: 			break;
     .      .  207: 		
     .      .  208: 		// Spin-lock
     .      .  209: 		case 's':
     .      .  210: 			__sync_lock_release(&spin_lock);
     .      .  211: 			break;
     .      .  212: 
     .      .  213: 		// Without locks
     .      .  214: 		default:
     .      .  215: 			break;
     .      .  216: 	}
     .      .  217: 
     .      .  218: 
     .      .  219: 	// Get the list length
     .      .  220: 	listlen = SortedList_length(list);
     .      .  221: 
     .      .  222: 	return NULL;
     .      .  223: }	
---
     .      .  224: 
     .      .  225: // Main routine 
     .      .  226: int main(int argc, char *argv[]){
     .      .  227: 
     .      .  228: 	// Default values
ROUTINE ====================== worker in /u/eng/ugrad/beb/lab2b/lab2_list.c
    28     37 Total samples (flat / cumulative)
     .      .   82: 		free(rand_key);
     .      .   83: 	}
     .      .   84: }
     .      .   85: 
     .      .   86: // Thread routine
---
     .      .   87: void* worker(void* tID){
     .      .   88: 
     .      .   89: 	// Lock timers
     .      .   90: 	struct timespec lock_start, lock_end;
     .      .   91: 
     .      .   92: 	// Insert elements into list
     .      .   93: 
     .      .   94: 	/* Fine Grained Locking */
     .      .   95: 	// int i;
     .      .   96: 	// for(i = *(int*)tID; i < numelems; i+= numthreads){
     .      .   97: 	// 	switch(m_sync){
     .      .   98: 	//		
     .      .   99: 	// 		// Mutex
     .      .  100: 	// 		case 'm':
     .      .  101: 	// 			pthread_mutex_lock(&mutex);
     .      .  102: 	// 			SortedList_insert(list, &elements[i]);
     .      .  103: 	// 			pthread_mutex_unlock(&mutex);
     .      .  104: 	// 			break;
     .      .  105: 	//		
     .      .  106: 	// 		// Spin-lock
     .      .  107: 	// 		case 's':
     .      .  108: 	// 			while(__sync_lock_test_and_set(&spin_lock, 1))
     .      .  109: 	// 				;
     .      .  110: 	// 			SortedList_insert(list, &elements[i]);
     .      .  111: 	// 			__sync_lock_release(&spin_lock);
     .      .  112: 	// 			break;
     .      .  113: 	//
     .      .  114: 	// 		// Without locks
     .      .  115: 	// 		default:
     .      .  116: 	// 			SortedList_insert(list, &elements[i]);
     .      .  117: 	// 			break;
     .      .  118: 	// 	}
     .      .  119: 	// }
     .      .  120: 
     .      .  121: 	/* Course Grained Locking */
     .      .  122: 	switch(m_sync){
     .      .  123: 	
     .      .  124: 	// Mutex
     .      .  125: 	case 'm':
     .      .  126: 		
     .      .  127: 		// Time the wait for thread to acquire mutex
     .      .  128: 		if(clock_gettime(CLOCK_MONOTONIC, &lock_start) == -1){
     .      .  129: 			fprintf(stderr, "Error getting lock start time\n");
     .      .  130: 			exit(1);
     .      .  131: 		}
     .      .  132: 		pthread_mutex_lock(&mutex);
     .      .  133: 		if(clock_gettime(CLOCK_MONOTONIC, &lock_end) == -1){
     .      .  134: 			fprintf(stderr, "Error getting lock end time\n");
     .      .  135: 			exit(1);
     .      .  136: 		}
     .      .  137: 
     .      .  138: 		// Calculate wait time
     .      .  139: 		long long wait_time = 1000000000 * (lock_end.tv_sec - lock_start.tv_sec) + (lock_end.tv_nsec - lock_start.tv_nsec);
     .      .  140: 		locktimers[*(int*)tID] = wait_time;
     .      .  141: 
     .      .  142: 		break;
     .      .  143: 	
     .      .  144: 	// Spin-lock
     .      .  145: 	case 's':
    27     27  146: 		while(__sync_lock_test_and_set(&spin_lock, 1))
     .      .  147: 			;
     .      .  148: 		break;
     .      .  149: 
     .      .  150: 	// Without locks
     .      .  151: 	default:
     .      .  152: 		break;
     .      .  153: 	}
     .      .  154: 
     .      .  155: 	int i;
     1      1  156: 	for(i = *(int*)tID; i < numelems; i+= numthreads)
     .      9  157: 		SortedList_insert(list, &elements[i]);
     .      .  158: 
     .      .  159: 	// Get the list length
     .      .  160: 	listlen = SortedList_length(list);
     .      .  161: 	
     .      .  162: 	// Check if the length of list is zero
     .      .  163: 	if(listlen == -1){
     .      .  164: 		fprintf(stderr, "Error: List length is corrupted after insertion; it is: %d\n",listlen);
     .      .  165: 		exit(2);
     .      .  166: 	}
     .      .  167: 
     .      .  168: 	// Look up and delete each of the keys it had previously inserted
     .      .  169: 	
     .      .  170:    	/* Fine Grained Locking */
     .      .  171: 	// int j;
     .      .  172: 	// for(j = *(int*)tID; j < numelems; j+= numthreads){
     .      .  173: 	// 	switch(m_sync){
     .      .  174: 	//
     .      .  175: 	// 		// Mutex
     .      .  176: 	// 		case 'm':
     .      .  177: 	// 			pthread_mutex_lock(&mutex);
     .      .  178: 	// 			SortedList_delete(SortedList_lookup(list, elements[j].key));
     .      .  179: 	// 			pthread_mutex_unlock(&mutex);
     .      .  180: 	//
     .      .  181: 	// 		// Spin-lock
     .      .  182: 	// 		case 's':
     .      .  183: 	// 			while(__sync_lock_test_and_set(&spin_lock, 1))
     .      .  184: 	// 				;
     .      .  185: 	// 			SortedList_delete(SortedList_lookup(list, elements[j].key));
     .      .  186: 	// 			__sync_lock_release(&spin_lock);
     .      .  187: 	//
     .      .  188: 	// 		// Without locks
     .      .  189: 	// 		default:
     .      .  190: 	// 			SortedList_delete(SortedList_lookup(list, elements[j].key));
     .      .  191: 	// 			break;
     .      .  192: 	// 	}
     .      .  193: 	// }
     .      .  194: 
     .      .  195: 
     .      .  196: 	// Course Grained Locking
     .      .  197: 	int j;
     .      .  198: 	for(j = *(int*)tID; j < numelems; j+= numthreads)
     .      .  199: 		SortedList_delete(SortedList_lookup(list, elements[j].key));
     .      .  200: 
     .      .  201: 	switch(m_sync){
     .      .  202: 	
     .      .  203: 		// Mutex
     .      .  204: 		case 'm':
     .      .  205: 			pthread_mutex_unlock(&mutex);
     .      .  206: 			break;
     .      .  207: 		
     .      .  208: 		// Spin-lock
     .      .  209: 		case 's':
     .      .  210: 			__sync_lock_release(&spin_lock);
     .      .  211: 			break;
     .      .  212: 
     .      .  213: 		// Without locks
     .      .  214: 		default:
     .      .  215: 			break;
     .      .  216: 	}
     .      .  217: 
     .      .  218: 
     .      .  219: 	// Get the list length
     .      .  220: 	listlen = SortedList_length(list);
     .      .  221: 
     .      .  222: 	return NULL;
     .      .  223: }	
---
     .      .  224: 
     .      .  225: // Main routine 
     .      .  226: int main(int argc, char *argv[]){
     .      .  227: 
     .      .  228: 	// Default values
